
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
  relationMode = "prisma"
}

generator client {
  provider = "prisma-client-js"
}

enum EWalletType {
  DEPOSIT
  FEE_PAYER_FUND
  SERVICE_FUNDING
  VOLUME
  FEES
  MARKET_MAKING
  SNIPING
  SNIPING_FUNDING
}

enum EJobStatus {
  OPEN
  FINISHED
  FAILED
}



model CompanyWallet {
  pubkey String @id

  encryptedPrivKey String

  type EWalletType

  isActive Boolean @default(true) // if the wallet is still actively used, especially useful for sub wallets
   
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
}

enum EServiceType {
  VOLUME
  RANKING
  MARKET_MAKING
  SNIPER
}

model SplToken {
  tokenMint      String                        @id
  symbol         String                        
  name           String                        
  decimals       Int                           @default(9)
  isSPL          Boolean                       @default(true)
  createdAt      DateTime                      @default(now())
  updatedAt      DateTime                      @updatedAt
  lastUsdcPrice  Float?

  usedInBookedServices BookedService[]
}



model BookedService {
  id String @id @default(cuid())

  type EServiceType

  isActive Boolean @default(true)

  usedSplTokenMint String
  usedSplToken SplToken @relation(fields: [usedSplTokenMint], references: [tokenMint])

  solAmountForService Float?

  botCustomerId String 
  botCustomer BotCustomer @relation(fields: [botCustomerId], references: [id])

  mainWallet BotCustomerWallet @relation(fields: [mainWalletId], references: [pubkey])
  mainWalletId String @unique

  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  description String?

  cycles MarketMakingCycle[]
}

model BotCustomerWallet {
  pubkey String @id

  encryptedPrivKey String

  type EWalletType

  botCustomerId String 
  botCustomer BotCustomer @relation(fields: [botCustomerId], references: [id])

  isActive Boolean @default(true) // if the wallet is still actively used, especially useful for sub wallets
   
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  latestSolBalance Float?
  latestTokenBalance Float?

  service BookedService?

  buyMarketMakingJobs MarketMakingJob[] @relation("buyTransactionsForWallet")
  sellMarketMakingJobs MarketMakingJob[] @relation("sellTransactionsForWallet")
}

model BotCustomer {
  id String @id @default(cuid())

  name String?
  email String?
  telegramUsername String?

  walletsAssociated BotCustomerWallet[]  
  bookedServices BookedService[]

  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  cycles MarketMakingCycle[]
}


enum EMarketMakingCycleType {
  PRE_PUSH
  PUSH
  POST_PUSH
  MAINTAIN
  TAKE_PROFIT
}

model MarketMakingCycle {
  id String @id @default(cuid())

  type EMarketMakingCycleType

  isActive Boolean @default(true)

  botCustomerId String
  botCustomer BotCustomer @relation(fields: [botCustomerId], references: [id])

  bookedServiceId String
  bookedService BookedService @relation(fields: [bookedServiceId], references: [id])

  solSpentForCycle Float
  maxSolSpentForCycle Float

  solEarnedForCycle Float
  maxSolEarnedForCycle Float

  buyMinAmount Float
  buyMaxAmount Float

  sellToBuyValueRatio Float // >1 => extract value, <1 => add value

  minDurationBetweenBuyAndSellInSeconds Int // 30 - 100 seconds; but smaller than durationBetweenJobsInSeconds
  maxDurationBetweenBuyAndSellInSeconds Int // 30 - 100 seconds; but smaller than durationBetweenJobsInSeconds

  minDurationBetweenJobsInSeconds Int // 60 - 300 seconds
  maxDurationBetweenJobsInSeconds Int // 60 - 300 seconds

  plannedTotalDurationInMinutes Int?

  startTimestamp DateTime? @default(now())
  endTimestamp DateTime?

  updatedAt             DateTime           @updatedAt

  jobs MarketMakingJob[]
}


model MarketMakingJob {
  id String @id @default(cuid())

  cycleId String
  cycle MarketMakingCycle @relation(fields: [cycleId], references: [id])

  buyStatus EJobStatus @default(OPEN)
  sellStatus EJobStatus @default(OPEN)

  // BUY

  buyWalletPubkey String?
  buyWallet BotCustomerWallet? @relation("buyTransactionsForWallet", fields: [buyWalletPubkey], references: [pubkey])

  buyStartedAt DateTime?

  earliestExecutionTimestampForBuy DateTime? // last job sets this to when the job can be executed the earliest
  latestExecutionTimestampForBuy DateTime? // last job sets this to when the job can be executed the latest
  executedAtForBuy DateTime?

  buyExpectedTokenOutputAmount Float?
  buyOutputTokenBalance Float?

  tokenPriceAtBuy Float?
  solSpent Float?
  tokenBought Float?

  buyTransactionSignature String?
  buyTransaction OnChainTransaction? @relation("buyTransactions", fields: [buyTransactionSignature], references: [transactionSignature]) 

  // SELL

  sellWalletPubkey String?
  sellWallet BotCustomerWallet? @relation("sellTransactionsForWallet", fields: [sellWalletPubkey], references: [pubkey])

  sellStartedAt DateTime?

  earliestExecutionTimestampForSell DateTime? // after the buy, this job sets this to when it should sell the earliest
  latestExecutionTimestampForSell DateTime? // after the buy, this job sets this to when it should sell the latest
  executedAtForSell DateTime?

  sellExpectedSolOutputAmount Float?
  sellOutputSolBalance Float?

  tokenPriceAtSell Float?
  solEarned Float?
  tokenSold Float?

  sellTransactionSignature String?
  sellTransaction OnChainTransaction? @relation("sellTransactions", fields: [sellTransactionSignature], references: [transactionSignature])

  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
}

model OnChainTransaction {
  transactionSignature String @id

  status EOnChainTransactionStatus

  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  marketMakingJobs MarketMakingJob[] @relation("buyTransactions")
  marketMakingJobsSell MarketMakingJob[] @relation("sellTransactions")
}

enum EOnChainTransactionStatus {
  SUCCESS
  FAILED
}